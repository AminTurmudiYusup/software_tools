## Предварительное условие
1. Убедитесь, что Make уже включен в CI/CD github (эти инструменты используются для автоматизации процесса компиляции и связывания вашего исходного кода в исполняемую программу)


![qemu1](https://github.com/user-attachments/assets/e4cb10e0-6e92-4d13-a0d8-5500fbc56d10)




2. Убедитесь, что симулятор включен в CI/CD github, я использую qemu (с поддержкой RISC-V)


![riscv6](https://github.com/user-attachments/assets/f8e3a8bc-94a5-4873-9e53-a77e88b6e3a4)



## Написание и тестирование программы
1. Написание программы для вычисления факториала для архитектуры RISC-V


![qemufactorial](https://github.com/user-attachments/assets/d647e31b-b78c-4685-9187-47c47f402101)





2. Написание программы для вычисления числа Фибоначчи для архитектуры RISC-V


![qemufibo](https://github.com/user-attachments/assets/0d4944fa-2345-48c6-854e-4a76dd61cea0)



3. Написание модульного теста с использованием C


![riscv4](https://github.com/user-attachments/assets/62a99292-e6fd-421c-9d1f-05b85e85665a)

- Уже написанная программа будет вызвана и протестирована на C
- Поэтому я удалил системные вызовы для печати и остановки симулятора, поскольку они не нужны при вызове из C
4. Создайте файл Makefile для системы сборки, которая генерирует собственные скрипты сборки


![qemu2](https://github.com/user-attachments/assets/95e5f36e-70fd-4bfb-8e7f-c176d4560c6d)


5. Запустить программу локально



![qemutest3](https://github.com/user-attachments/assets/92c91a1e-ed54-416e-abd9-bcbfb12f8a09)


  
6. Измените файл yaml для поддержки задачи CI/CD RISC-V


![qemucicd](https://github.com/user-attachments/assets/b4c9d78e-db23-4453-b977-c3a108ba1a64)
    


7. Запустите CI/CD



![qemuunittest](https://github.com/user-attachments/assets/b8ea98f1-f721-4969-901f-4e0f1d7226e6)



## Заключение
1. Нам не нужно физическое оборудование, потому что симулятор воссоздает поведение реальной системы в контролируемой виртуальной среде. Например, в контексте RISC-V симулятор имитирует поведение ЦП RISC-V
2. Симулятор помогает тестировать код, написанный для определенной архитектуры ЦП (например, RISC-V)
3. Когда Make, Cmake или Meson собирают системы, генерируют двоичные файлы для целевых архитектур (например, RISC-V)
4. Этот рабочий процесс (написание кода, сборка кода, связывание кода, запуск кода и код модульного тестирования) имеет решающее значение во встраиваемых системах, исследовании архитектуры и разработке программного обеспечения при работе с новыми или недоступными аппаратными платформами.
